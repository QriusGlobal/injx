name: Release

'on':
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (auto determines from commits)'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
      dry_run:
        description: 'Dry run (no actual release)'
        required: false
        default: false
        type: boolean
      target_environment:
        description: 'Release target environment (release=production, testpypi=testing)'
        required: true
        default: 'testpypi'
        type: choice
        options:
          - testpypi
          - release

permissions:
  contents: read

jobs:
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@e2f20e631ae6d7dd3b768f56a5d2af784dd54791  # v4.1.0
        with:
          fetch-depth: 0  # Required for semantic-release to analyze commits

      - name: Setup uv
        uses: astral-sh/setup-uv@b75a909f75acd358c2196fb9a5f1299a9a8868a4  # v6.7.0
        with:
          enable-cache: true
          cache-dependency-glob: |
            **/pyproject.toml
            **/uv.lock
          prune-cache: false

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Format check
        run: uv run ruff format --check src tests

      - name: Lint check
        run: uv run ruff check src tests

      - name: Type check
        run: uv run basedpyright src

      - name: Run tests
        run: uv run pytest -q --maxfail=1

  release:
    name: ${{ inputs.target_environment == 'testpypi' && 'Test Release (TestPyPI)' || 'Production Release (PyPI)' }}
    needs: quality-gates
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment: ${{ inputs.target_environment }}
    permissions:
      id-token: write  # OIDC for PyPI/TestPyPI
      contents: write  # Git operations
    outputs:
      version: ${{ steps.release.outputs.version }}
      released: ${{ steps.release.outputs.released }}
    steps:
      - name: Checkout
        uses: actions/checkout@e2f20e631ae6d7dd3b768f56a5d2af784dd54791  # v4.1.0
        with:
          fetch-depth: 0  # Required for semantic-release
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup uv
        uses: astral-sh/setup-uv@b75a909f75acd358c2196fb9a5f1299a9a8868a4  # v6.7.0
        with:
          enable-cache: true
          cache-dependency-glob: |
            **/pyproject.toml
            **/uv.lock
          prune-cache: false
          save-cache: ${{ inputs.dry_run == false }}

      - name: Install dependencies
        run: uv sync --extra dev

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Determine release version
        id: check-version
        run: |
          # Get current version
          CURRENT_VERSION=$(uv run python -c \
            "import tomllib; import pathlib; \
            print(tomllib.loads(pathlib.Path('pyproject.toml').read_text())['project']['version'])")
          echo "Current version: $CURRENT_VERSION"

          # Determine next version based on input
          if [[ "${{ inputs.release_type }}" == "auto" ]]; then
            # Let semantic-release determine from commits
            NEXT_VERSION=$(uv run semantic-release version --print)
          else
            # Use specified bump type
            NEXT_VERSION=$(uv run semantic-release version --print --${{ inputs.release_type }})
          fi

          if [[ "$NEXT_VERSION" == "$CURRENT_VERSION" ]]; then
            echo "No release needed - no changes since last release"
            echo "next_version=$CURRENT_VERSION" >> "$GITHUB_OUTPUT"
            echo "needs_release=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will release version: $NEXT_VERSION"
            echo "next_version=$NEXT_VERSION" >> "$GITHUB_OUTPUT"
            echo "needs_release=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Version and build
        id: release
        if: steps.check-version.outputs.needs_release == 'true' && inputs.dry_run == false
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating ${{ inputs.target_environment == 'testpypi' && 'TestPyPI' || 'production' }} release..."

          # Run semantic-release with environment-specific flags
          if [[ "${{ inputs.target_environment }}" == "testpypi" ]]; then
            # TestPyPI: No Git tags, no push to avoid polluting version history
            if [[ "${{ inputs.release_type }}" == "auto" ]]; then
              uv run semantic-release -v version --no-push --no-vcs-release
            else
              uv run semantic-release -v version --no-push --no-vcs-release --${{ inputs.release_type }}
            fi
          else
            # Production: Create Git tags and push for real releases
            if [[ "${{ inputs.release_type }}" == "auto" ]]; then
              uv run semantic-release -v version --push --vcs-release
            else
              uv run semantic-release -v version --push --vcs-release --${{ inputs.release_type }}
            fi
          fi

          # Build packages with updated version
          rm -rf dist
          uv build
          echo "Built packages:"
          ls -la dist/

          # Get the new version that was just set
          NEW_VERSION=$(uv run python -c \
            "import tomllib; import pathlib; \
            print(tomllib.loads(pathlib.Path('pyproject.toml').read_text())['project']['version'])")
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "released=true" >> "$GITHUB_OUTPUT"

      - name: Dry run summary
        if: inputs.dry_run == true
        run: |
          echo "version=${{ steps.check-version.outputs.next_version }}" >> "$GITHUB_OUTPUT"
          echo "released=false" >> "$GITHUB_OUTPUT"
          {
            echo "## Dry Run Complete"
            echo "Would have released version: ${{ steps.check-version.outputs.next_version }}"
            echo "Target: ${{ inputs.target_environment == 'testpypi' && 'TestPyPI' || 'Production PyPI' }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Publish to TestPyPI
        if: >-
          steps.check-version.outputs.needs_release == 'true' &&
          inputs.dry_run == false &&
          inputs.target_environment == 'testpypi'
        run: |
          echo "Publishing to TestPyPI to test release process..."
          uv publish --publish-url https://test.pypi.org/legacy/ --trusted-publishing always
          echo "Published version ${{ steps.release.outputs.version }} to TestPyPI"

      - name: Publish to PyPI
        if: >-
          steps.check-version.outputs.needs_release == 'true' &&
          inputs.dry_run == false &&
          inputs.target_environment == 'release'
        run: |
          echo "Publishing to production PyPI..."
          uv publish --trusted-publishing always
          echo "Published version ${{ steps.release.outputs.version }} to PyPI"

      - name: Release summary
        if: always() && inputs.dry_run == false
        run: |
          if [[ "${{ steps.check-version.outputs.needs_release }}" == "false" ]]; then
            {
              echo "## No Release Needed"
              echo "No changes detected since last release."
            } >> "$GITHUB_STEP_SUMMARY"
          elif [[ "${{ steps.release.outputs.released }}" == "true" ]]; then
            VERSION="${{ steps.release.outputs.version }}"
            REPO="${{ github.repository }}"

            {
              echo "## ${{ inputs.target_environment == 'testpypi' && 'TestPyPI' || 'Production' }} Release Complete"
              echo "Released version: $VERSION"

              if [[ "${{ inputs.target_environment }}" == "testpypi" ]]; then
                echo "- TestPyPI: https://test.pypi.org/project/injx/$VERSION/"
                echo ""
                echo "**Test the release:**"
                echo "\`\`\`bash"
                echo "pip install -i https://test.pypi.org/simple/ injx==$VERSION"
                echo "\`\`\`"
                echo ""
                echo "**If tests pass, create production release:**"
                echo "Run this workflow again with \`target_environment: release\`"
              else
                echo "- PyPI: https://pypi.org/project/injx/$VERSION/"
                GITHUB_URL="https://github.com/$REPO/releases/tag/v$VERSION"
                echo "- GitHub: $GITHUB_URL"
              fi
            } >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "## Release Failed"
              echo "Check the logs for details."
            } >> "$GITHUB_STEP_SUMMARY"
          fi

  docs:
    name: Deploy Documentation
    needs: release
    if: needs.release.outputs.released == 'true' && inputs.target_environment == 'release'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@e2f20e631ae6d7dd3b768f56a5d2af784dd54791  # v4.1.0
        with:
          fetch-depth: 0  # Required for mike
          ref: main  # Get the latest with version bump

      - name: Setup uv
        uses: astral-sh/setup-uv@b75a909f75acd358c2196fb9a5f1299a9a8868a4  # v6.7.0
        with:
          enable-cache: true
          cache-dependency-glob: |
            **/pyproject.toml
            **/uv.lock
          prune-cache: false

      - name: Install documentation dependencies
        run: uv sync --extra docs

      - name: Configure git for mike
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Deploy versioned documentation
        run: |
          VERSION="${{ needs.release.outputs.version }}"

          # Check if this is a pre-release
          if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            # Stable release: update 'latest' alias
            echo "Deploying docs for v$VERSION and updating 'latest'"
            uv run mike deploy --push --branch gh-pages --update-aliases "$VERSION" latest
          else
            # Pre-release: don't update 'latest'
            echo "Deploying pre-release docs for v$VERSION"
            uv run mike deploy --push --branch gh-pages "$VERSION"
          fi

          echo "Documentation deployed successfully"
